## Hashing
해시 함수는 입력을 받아 프로그래머 설장한 고정 크기보다 작은 정수로 확정적으로 변하는 함수다.

입력은 key라고 하며 동일한 입력은 항상 동일한 정수로 변환된다.

다음은 영어 알파벳 문자를 포함하는 문자열에 대한 예시 해시 알고리즘이다.

1. 정수 total를 선언한다.
2. 문자열을 반복한다. 각 문자에 대해 알파벳의 해당 위치로 변환한다. 예를 들어, a->1, c->3, z->26.
3. 해당 값을 가져와 문자열의 현재 위치(index + 1)로 곱한다. 예를 들어, 문자열 "abc"가 주어지면, b는 알파벳의 2번째 자리에 위치하고 있고 이 문자열의 2번째 자리에 위치하고 있으므로 total값에 2*2=4의 값이 더해진다.
4. 모든 문자를 이러한 공정을 거친 후, total의 변환된 값을 얻게된다.

이 알고리즘은 실제로 좋은 해시함수는 아니지만(해시함수를 "좋은"것으로 만드는 요소는 추후의 이야기에 존재한다.) 문자열을 정수로 변환하는 방법의 예이다.
total을 고정된 크기로 제한할 필요가 없는지 궁금할 수 있다. 맞다. 이 알고리즘은 잘못되었다. 이 알고리즘에서는 한도를 정해야한다. 이를 x라고 하자.
그리고 4단계를 다음과 같이 변경한다.

**모든 문자를 거쳐, total % x를 최종 값으로 얻는다**

% 모듈로 연산하고, 최종 변환 값이 항상 x보다 작도록 한다.

### 해시 함수의 요점?
우리는 배열이 임의 접근시 O(1) 가진다는 것을 알고있다.
배열의 주요 제약은 크기가 고정되어 있고 인덱스가 정수여야 한다는 것이다. 해시 함수는 모든 입력을 정수로 변환할 수 있기 때문에 배열을 해시 함수와 결합하면 **해시 테이블** 또는 **dictionary** 이라고 하는 해시 맵을 만들 수 있다.
그리고나서 우리는 본질적으로 정수를 인덱스로 제한하지 않은 배열의 임의 접근으로 O(1)을 가질 수 있다.
배열을 사용하여 인덱스를 값에 매핑한다.

>해시 맵은 작업하기가 더 쉽고 깔끔하다.
> 키가 정수이고 배열을 사용하여 문제를 해결할 수 있더라도 키의 최대 크기를 모른다면 배열의 크기를 얼마나 크게 조정해야 하는지 알 수 없다.
> 해시맵을 사용하면 키가 크기 제한 내에서 새로운 정수로 변환되므로 걱정할 필요가 없다.

#### 단점
실용적인 관점에서 보면 해시맵을 사용하는 데에는 몇가지 단점이 있으며, 인터뷰에서 장단점에 대해 이야기하는 것이 일반적이므로 이를 아는 것이 중요하다.
해시 맵의 가장 큰 단점은 입력 크기가 작을수록 오버헤드로 인해 속도가 느려질 수 있다는 것이다.
Big O는 상수를 무시하기 때문에 시간 복잡성을 때때로 속일 수 있다. 왜냐하면 모든 키는 해시함수를 거처야하고 충돌도 있을 수 있기 때문이다.

#### 충돌
서로 다른 키가 동일한 정수로 변환되는 경우를 충돌이라고 한다.
충돌을 처리하지 않으면 이전 키가 무시되고 데이터가 손실된다. 충돌을 처리하는 방법에는 여러가지가 있지만 여기서는 체인이라는 일반적인 방법에 대해 이야기 하겠습니다.

